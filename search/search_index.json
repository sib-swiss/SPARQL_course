{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Course website","text":""},{"location":"#material","title":"Material","text":"<ul> <li>This website</li> <li>Zoom meeting (through mail)</li> <li>Google doc (through mail)</li> <li>Recon4IMD Teams channel: #SPARQL Course</li> </ul>"},{"location":"#learning-outcomes","title":"Learning outcomes","text":""},{"location":"#general-learning-outcomes","title":"General learning outcomes","text":"<p>After this course, you will be able to:</p>"},{"location":"#learning-outcomes-explained","title":"Learning outcomes explained","text":"<p>To reach the general learning outcomes above, we have set a number of smaller learning outcomes. Each chapter starts with these smaller learning outcomes. Use these at the start of a chapter to get an idea of what you will learn. Use them also at the end of a chapter to evaluate whether you have learned what you were expected to learn.</p>"},{"location":"#learning-experiences","title":"Learning experiences","text":"<p>To reach the learning outcomes we will use lectures, exercises, polls and group work. During exercises, you are free to discuss with other participants. During lectures, focus on the lecture only.</p>"},{"location":"#exercises","title":"Exercises","text":"<p>Each block has practical work involved. Some more than others. The practicals are subdivided into chapters, and we\u2019ll have a (short) discussion after each chapter. All answers to the practicals are incorporated, but they are hidden. Do the exercise first by yourself, before checking out the answer. If your answer is different from the answer in the practicals, try to figure out why they are different.</p>"},{"location":"#asking-questions","title":"Asking questions","text":"<p>During lectures, you are encouraged to raise your hand if you have questions (if in-person), or use the Zoom functionality (if online). Find the buttons in the participants list (\u2018Participants\u2019 button):</p> <p>Alternatively, (depending on your zoom version or OS) use the \u2018Reactions\u2019 button:</p> <p>A main source of communication will be our Recon4IMD Teams channel. Ask background questions that interest you personally at #background. During the exercises, e.g. if you are stuck or don\u2019t understand what is going on, use the Teams channel #SPARQL Course.  This channel is not only meant for asking questions, but also for answering questions of other participants. If you are replying to a question, use the \u201creply in thread\u201d option:</p> <p>The teacher will review the answers, and add/modify if necessary. If you\u2019re really stuck and need specific tutor support, write the teachers or helpers personally.</p> <p>To summarise:</p> <ul> <li>During lectures: raise hand/zoom functionality</li> <li>Personal interest questions: #background</li> <li>During exercises: #SPARQL Course on Teams</li> </ul>"},{"location":"course_schedule/","title":"Course schedule","text":"start end topic 09:00 09:15 Welcome! 09:15 09:45 SPARQL : basic concepts introdution - M. Pagni 09:45 10:15 GraphDB intro - M. Pagni 10:00 Hey Jude: Explore the Beatles graph Examples on the GBA1 protein: same queries than Beatles on GBA1 From GraphDB to the UniProt SPARQL interface (and/or Wikidata) Explain queries with ChatGPT ??? Afternoon Federated queries What about Recon4IMD? The ReconXKG graph"},{"location":"music/","title":"Music example","text":""},{"location":"music/#learning-outcomes","title":"Learning outcomes","text":"<p>After having completed this chapter you will be able to:</p> <ul> <li>Understand the structure of a simple database encoded in turtle</li> <li>Write simple SELECT SPARQL queries</li> </ul>"},{"location":"music/#material","title":"Material","text":"<p>The exercises below are based on this tutorial and data from Stardog.</p> <p>Let\u2019s look at a small example of the music database:</p> beatles_notsimplified.ttl<pre><code>PREFIX : &lt;http://contextualise.dev/ontology/&gt;\nPREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\nPREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;\n\n:The_Beatles      rdf:type  :Band .\n:The_Beatles      :name     \"The Beatles\" .\n:The_Beatles      :member   :John_Lennon .\n:The_Beatles      :member   :Paul_McCartney .\n:The_Beatles      :member   :Ringo_Starr .\n:The_Beatles      :member   :George_Harrison .\n:John_Lennon      rdf:type  :SoloArtist .\n:Paul_McCartney   rdf:type  :SoloArtist .\n:Ringo_Starr      rdf:type  :SoloArtist .\n:George_Harrison  rdf:type  :SoloArtist .\n:Please_Please_Me rdf:type  :Album .\n:Please_Please_Me :name     \"Please Please Me\" .\n:Please_Please_Me :date     \"1963-03-22\"^^xsd:date .\n:Please_Please_Me :artist   :The_Beatles .\n:Please_Please_Me :track    :Love_Me_Do .\n:Love_Me_Do       rdf:type  :Song .\n:Love_Me_Do       :name     \"Love Me Do\" .\n:Love_Me_Do       :length   125 .\n:Love_Me_Do       :writer   :John_Lennon .\n:Love_Me_Do       :writer   :Paul_McCartney .\n</code></pre> <p>Could it be simplified?</p> <p>Let\u2019s look at its structure when connecting the entities:</p> <p>Now let\u2019s use a bigger music database that uses the same structure (it\u2019s from DBpedia):</p> <p>Download the ttl file <code>music.ttl</code></p> <p>It is already loaded on the ReconXKG server (https://reconx.vital-it.ch), but you can also install it on your local instance if you wish.</p> <p>Now select the albums from our database:</p> select_album.sparql<pre><code>PREFIX : &lt;http://stardog.com/tutorial/&gt;\nPREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\n\nSELECT ?album\nWHERE {\n   ?album rdf:type :Album .\n}\n</code></pre> <p>Exercise: Now adapt the query to select all the solo artists</p> Answer <pre><code>PREFIX : &lt;http://stardog.com/tutorial/&gt;\nPREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\n\nSELECT ?artist\nWHERE {\n    ?artist rdf:type :SoloArtist .\n}\n</code></pre>"},{"location":"music/#basic-graph-patterns","title":"Basic Graph Patterns","text":"<p>When one or more triple patterns are used together, they form what is known as a Basic Graph Pattern (BGP). Let\u2019s add one more triple pattern to our previous query to retrieve the artist for each album:</p> <pre><code>PREFIX : &lt;http://stardog.com/tutorial/&gt;\nPREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\n\nSELECT *\nWHERE {\n    ?album rdf:type :Album .\n    ?album :artist ?artist .\n}\n</code></pre> <p>What does the * mean here?</p> <p>Exercise: Add the solo artists and album \u201cnice\u201d names to this query. Hide the IDs from the results. Reorder by artist - album</p> Answer <pre><code>PREFIX : &lt;http://stardog.com/tutorial/&gt;\nPREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\n\nSELECT ?artist_name ?album_name\nWHERE {\n  ?album rdf:type :Album .\n    ?album :name ?album_name .\n    ?album :artist ?artist .\n    ?artist :name ?artist_name .\n}\n</code></pre> <p>Now let\u2019s add a third triple pattern to require that the returned artists should be of the SoloArtist type:</p> <pre><code>PREFIX : &lt;http://stardog.com/tutorial/&gt;\nPREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\n\nSELECT *\n{\n   ?album a :Album .\n   ?album :artist ?artist .\n   ?artist a :SoloArtist .\n}\n</code></pre> <p>The third pattern matches 276 triples in our graph by itself, but because some solo artists have put out more than one album, 604 results are returned.</p>"},{"location":"music/#ordering-results","title":"Ordering Results","text":"<p>Now we\u2019ll run the following query, which includes album dates:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date .\n}\n</code></pre> <p>If we want the results to be ordered based on a sorting condition, we can add an ORDER BY:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date .\n}\nORDER BY ?date\n</code></pre> <p>Now albums will be returned ordered by their release dates.</p> <p>It is possible to have multiple sorting conditions by specifying multiple variables (or even function calls) in ORDER BY. We can also sort the results in descending order by encapsulating the sort condition with the DESC keyword, like this: DESC(?date).</p> <p>Limiting Results When a query returns too many results, we can limit the results with the LIMIT keyword:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date\n}\nORDER BY desc(?date)\nLIMIT 2\n</code></pre> <p>In this query, we changed the dates to be sorted in reverse chronological order and limited the query to return only two results</p>"},{"location":"music/#filtering-results","title":"Filtering Results","text":"<p>We can filter the results returned by a query using a FILTER expression. SPARQL supports many built-in functions for writing such expressions:</p> <p>comparison operators: (=, !=, &lt;, &lt;=, &gt;, &gt;=) logical operators (&amp;&amp;, ||, !) mathematical operators (+, -, /, *)</p> <p>Plus many others.</p> <p>If we want to find the albums released in 1970 or later, we can do this with the following filter expression:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date\n   FILTER (?date &gt;= \"1970-01-01\"^^xsd:date)\n}\nORDER BY ?date\n</code></pre> <p>All otherwise matching results not satisfying the filter condition will be excluded from the results</p> <p>We can use any SPARQL function in the FILTER expressions. For example, the year function applied to a date value will return the year component as an integer value. So the following query will return the exact same results as the previous query, but the filter is written in a slightly different way:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date\n      FILTER (year(?date) &gt;= 1970)\n}\nORDER BY ?date\n</code></pre>"},{"location":"music/#binding-values","title":"Binding Values","text":"<p>We can assign the output of a function to a variable using the BIND keyword. This might be useful if we want to reuse the function result in different parts of the query or if we want to increase readability when we have a lot of nested function calls.</p> <p>We can rewrite the previous query by binding the output of the year(?date) expression to a new variable ?year first and using the variable in the filter expression:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date\n   BIND (year(?date) AS ?year)\n   FILTER (?year &gt;= 1970)\n}\nORDER BY ?date\n</code></pre> <p>Because we\u2019re selecting all variables with *, the new variable we\u2019ve bound will add another column to the output</p>"},{"location":"music/#removing-duplicates","title":"Removing Duplicates","text":"<p>Our music dataset is not complete by any means, and we have about a thousand albums. Suppose we want to find out the years in which these albums were released. One attempt would be to take the previous query, remove the filter, and only select the ?year variable.</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?year\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date\n   BIND (year(?date) AS ?year)\n}\nORDER BY ?date\n</code></pre> <p>But we will quickly discover that this query will still return many results, and the year values will be repeated:</p> <p>We can see that changing just the selected variables has no effect on the number of results returned by a query. We will still get one result for each matching pattern, so the number of rows in the result table won\u2019t change; only the number of columns will change.</p> <p>In order to get rid of duplicates, we need to use the DISTINCT keyword right after SELECT:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT DISTINCT ?year\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date\n   BIND (year(?date) AS ?year)\n}\nORDER BY ?year\n</code></pre> <p>The results won\u2019t have duplicates anymore</p>"},{"location":"music/#aggregation","title":"Aggregation","text":"<p>Aggregation is applying a function to a list of values rather than to a single value. Unlike regular functions, aggregate functions can only be used in SELECT expressions. Built-in aggregates provided in SPARQL are COUNT, SUM, MIN, MAX, AVG, GROUP_CONCAT, and SAMPLE.</p> <p>We can find the earliest and the latest release dates of albums in our dataset by using the MIN and MAX aggregates:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT (min(?date) as ?minDate) (max(?date) as ?maxDate)\n{\n    ?album a :Album ;\n           :date ?date\n}\n</code></pre> <p>We will get a single result with two columns</p> <p>The WHERE clause in this query would return a table with two columns and many rows if we didn\u2019t use the aggregate functions. The MIN (respectively, MAX) function looks at the values in the specified column of the results table and returns the single smallest (respectively, largest) value found.</p> <p>We can use the COUNT function to return the number of rows in the result table. The query to find the number of albums in our dataset is this:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT (count(?album) as ?count)\n{\n    ?album a :Album\n}\n</code></pre> <p>You can also count the relationships and how many times each type of relationship appears.</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?predicate (COUNT(?predicate) as ?predicateCount)\n{\n    ?subject ?predicate ?object .\n}\nGROUP BY ?predicate\nORDER BY DESC(?predicateCount)\n</code></pre>"},{"location":"music/#grouping","title":"Grouping","text":"<p>The previous aggregation examples worked over a single result table and returned a single row as the final result. We can also group the results based on the values of one or more variables and apply the aggregation functions to each group separately.</p> <p>Suppose we want to find the number of albums released each year. We can group the albums based on their release year and use the COUNT aggregate for each group:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?year (count(distinct ?album) AS ?count)\n{\n    ?album a :Album ;\n            :date ?date ;\n    BIND (year(?date) AS ?year)\n}\nGROUP BY ?year\nORDER BY desc(?count)\n</code></pre> <p>We will get one result for each distinct year value.</p> <p>You might notice that we used the DISTINCT keyword inside the count aggregate. This is because some of the albums in our date have duplicate release dates. For example, the album \u201cA Hard Day\u2019s Night\u201d has both 1964-06-26 and 1964-07-10 as release dates. This is due to the imperfection of our dataset, and using the DISTINCT keyword ensures we count the album only once for that year.</p> <p>This is not a perfect solution since it means we\u2019ll double count albums if their multiple release dates are in different years. It\u2019s better to clean up the data. Fortunately, we can use the aggregates to find which albums have multiple release dates:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?album (group_concat(?date) AS ?dates)\n{\n    ?album a :Album ;\n            :date ?date\n}\nGROUP BY ?album\nHAVING (count(?date) &gt; 1)\n</code></pre> <p>The HAVING keyword we used at the end acts like an overall filter on the query results. Since the aggregates can only be used in SELECT expressions, we cannot use a regular FILTER (without introducing a subquery), so the HAVING keyword provides an easy way to define such filters.</p>"},{"location":"music/#subqueries","title":"Subqueries","text":"<p>If we want to find the average number of albums released in a year, we need to use an aggregation function over the results of the previous query. This can be achieved by subqueries where we simply put a SELECT query inside another one:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT (avg(?count) AS ?avgCount)\n{\n      SELECT ?year (count(?album) AS ?count)\n      {\n            ?album a :Album ;\n                  :date ?date ;\n            BIND (year(?date) AS ?year)\n      }\n      GROUP BY ?year\n}\n</code></pre> <p>The result of this query will be a single value.</p> <p>Of course, subqueries don\u2019t have to use aggregation; it would be fine to use any kind of SELECT query as a subquery. If the outer WHERE clause contains additional patterns, then the subquery should be surrounded with {}.</p>"},{"location":"music/#union","title":"Union","text":"<p>In our data, we have artists separated into two types: bands and solo artists. If we want to retrieve all artists along with their names, then we can use the UNION operator to combine the matches from two different patterns:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?name\n{\n    { ?artist a :SoloArtist }\n    UNION\n    { ?artist a :Band }\n    ?artist :name ?name\n}\n</code></pre> <p>The results will contain artists matching either pattern.</p> <p>If the same artists matched both patterns, we would get a duplicate result and need DISTINCT to get unique results.</p> <p>But actually :Band and :SoloArtist are subclasses of :Artist:</p> <p>TODO check why query doesn\u2019t work</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?name\n{\n    ?artist a :Artist ;\n    rdfs:label ?name\n}\n</code></pre> <p>And we can see our results are exactly the same.</p>"},{"location":"music/#optional-matches","title":"Optional Matches","text":"<p>The following query returns the songs and their lengths:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n    ?song a :Song .\n    ?song :length ?length .\n}\nLIMIT 5000 # included to override default limit\n</code></pre> <p>When we look at the results, we see this query returns 3,640 results.</p> <p>Whereas the query without the second pattern returns 3,749 songs:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n    ?song a :Song .\n}\nLIMIT 5000 # included to override default limit\n</code></pre> <p>This means there are 109 songs in our dataset that do not have any length information.</p> <p>We can use OPTIONAL blocks to match patterns that may exist for some nodes but not for others:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?song ?length\n{\n    ?song a :Song .\n    OPTIONAL {\n        ?song :length ?length .\n    }\n}\nLIMIT 5000 # included to override default limit\n</code></pre> <p>This query will return 3,749 results, where 109 rows will not have a value for the length.</p> <p>If we only want to see those rows where length is missing, we can add a filter to our query:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?song ?length\n{\n    ?song a :Song .\n    OPTIONAL {\n        ?song :length ?length .\n    }\n    FILTER(!bound(?length))\n}\n</code></pre> <p>And we get the 109 results we were expecting.</p>"},{"location":"music/#negation","title":"Negation","text":"<p>The last example shows a somewhat indirect way to find patterns that do not exist in the dataset by using a combination of OPTIONAL and FILTER expressions. But SPARQL provides a special kind of filter for this purpose: NOT EXISTS. The following query will return the same 109 results as the previous query:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?song\n{\n    ?song a :Song .\n    FILTER NOT EXISTS {\n        ?song :length ?length .\n    }\n}\n</code></pre> <p>Any SPARQL construct can be used inside a NOT EXISTS block.</p>"},{"location":"music/#property-paths","title":"Property Paths","text":"<p>This is more advanced and optional for now ;)</p> <p>The triple patterns match triples in the dataset, so they can only be used to find nodes that are directly connected. We can use property paths to match nodes that are connected via arbitrary-length paths. More generally, a property path is a regular expression describing the possible route between two nodes in a graph. Property paths can also be used to express some graph patterns more concisely.</p> <p>To explore what we can do with property paths, we will start with this query that uses two ordinary triple patterns to find pairs of people who wrote songs together:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nselect distinct ?artist ?cowriter\n{\n    ?song :writer ?artist .\n    ?song :writer ?cowriter\n    FILTER (?artist != ?cowriter)\n}\n</code></pre> <p>We need DISTINCT in this query because the same pair might have cowritten multiple songs together. We need the FILTER because otherwise the query would match the songs with a single writer and bind the two variables ?artist and ?cowriter to the same person. Using a different variable does not ensure that the triple patterns match different triples in the data. This query returns each pair twice; we leave it as an exercise to the reader to come up with a different filter expression to return every pair only once.</p>"},{"location":"music/#inverse-path","title":"INVERSE PATH","text":"<p>Adding the symbol ^ in front of a predicate (or a property path expression) makes it an inverse path expression. An inverse path expression simply flips the direction of the match: the subject of the triple pattern will match the object of the triple in the data, and the object of the triple pattern will match the subject. So an equivalent way to write the previous query is as follows:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nselect distinct ?artist ?cowriter\n{\n    ?artist ^:writer ?song .\n    ?song :writer ?cowriter\n    FILTER (?artist != ?cowriter)\n}\n</code></pre> <p>By itself, an inverse property path expression is not very useful, but in combination with other property path expressions, it can be (as we will see next).</p>"},{"location":"music/#sequence-path","title":"SEQUENCE PATH","text":"<p>When the object of one triple pattern is the same as the subject of another triple pattern, and we are not interested in the binding of the variable, we can combine the two patterns using a sequence path. A sequence path means the subject is connected to the object via the path of property expressions specified in the sequence. The next query returns the same results as the previous query:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nselect distinct ?artist ?cowriter\n{\n    ?artist ^:writer/:writer ?cowriter\n    FILTER (?artist != ?cowriter)\n}\n</code></pre> <p>There can be more than two expressions in a path if necessary. We can also use constants for the subject or the object, or both. The next query returns cowriters of Paul McCartney:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nselect distinct ?cowriter\n{\n    :Paul_McCartney ^:writer/:writer ?cowriter\n    FILTER (?cowriter != :Paul_McCartney)\n}\norder by ?cowriter\n</code></pre>"},{"location":"music/#recursive-paths","title":"RECURSIVE PATHS","text":"<p>Suppose we want to find not only the cowriters of Paul McCartney, but also the cowriters of his cowriters, and continue finding cowriters recursively. We can use the recursive path operator + to follow a property path one or more times.</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nselect distinct ?cowriter\n{\n    :Paul_McCartney (^:writer/:writer)+ ?cowriter\n    FILTER (?cowriter != :Paul_McCartney)\n}\norder by ?cowriter\n</code></pre> <p>The other recursive operator, * , is used to follow a path zero or more times. Following a path zero times means we don\u2019t traverse any edges and simply return the same node as the starting node. This makes most sense when used in a sequence path as in rdf:type/rdfs:subClassOf*. This property path returns the type(s) of a node and all its superclasses.</p>"},{"location":"music/#optional-paths","title":"OPTIONAL PATHS","text":"<p>In our dataset, we have both the solo albums released by Paul McCartney and the albums released by The Beatles. The next query would return both kinds of album:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nselect ?album\n{\n  ?album :artist/:member? :Paul_McCartney\n}\n</code></pre> <p>The ? suffix means we should follow a path zero or one times. The property path expression :artist/:member? would start with an album and first find all the nodes connected via the :artist predicate and return those nodes (since we would end up on those nodes when we follow the :member edge zero times). Then, if any of those nodes have a :member edge, it will follow those edges and return the new nodes we reach as well.</p>"},{"location":"music/#alternative-paths","title":"ALTERNATIVE PATHS","text":"<p>Suppose we want to find all the songs related to Paul McCartney: songs released in either his solo albums or The Beatles\u2019 albums, along with the songs he wrote that were recorded by other artists. We need to find three alternate paths from songs to Paul McCartney. The previous property path expression already (partially) encodes two of these paths, and the third alternate path can be introduced using the | path operator:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nselect ?song\n{\n  ?song (^:track/:artist/:member?)|:writer :Paul_McCartney\n}\n</code></pre>"},{"location":"precourse/","title":"Pre-course preparations","text":""},{"location":"precourse/#software","title":"Software","text":"<p>We will be mainly working on a remote GraphDB instance, dedicated to Recon4IMD.</p> <p>Other SPARQL endpoints will also be used remotely.</p> <p>You can, if you want, install GraphDB on your own computer. The GraphDB semantic graph database is available for most computers here. Fill the form (Select <code>GraphDB Free</code>) to access the GraphDB download links.</p> <p>TO REMOVE ?</p> <p>Before the course, make sure you can comfortably work on a remote server. This means that you can approach it through the shell, modify scripts and transfer files. We can recommend <code>atom</code> for Linux and Mac, and <code>Notepad ++</code> in combination with MobaXterm for Windows. Therefore, install in your computer:</p> MacOS/Linux <ul> <li>SSH and scripting: Atom with packages like: <code>terminus</code> and <code>ftp-remote-edit</code></li> <li>Transferring files: FileZilla</li> </ul> Windows <ul> <li>SSH and scripting: MobaXterm and/or Notepad++ with the plugin <code>NppFTP</code></li> <li>Transferring files: FileZilla</li> </ul>"}]}