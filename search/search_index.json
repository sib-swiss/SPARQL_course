{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Course website","text":""},{"location":"#material","title":"Material","text":"<ul> <li>This website</li> <li>Zoom meeting (through mail)</li> <li>Google doc (through mail)</li> </ul>"},{"location":"concepts/","title":"RDF basic concepts","text":""},{"location":"concepts/#learning-outcomes","title":"Learning outcomes","text":"<p>After having completed this chapter, you will be able to:</p> <ul> <li>Understand RDF and SPARQL basic concepts</li> <li>Understand RDF and the Turtle (<code>ttl</code>) format</li> </ul>"},{"location":"concepts/#material","title":"Material","text":"<p> Download the presentation</p> <p>Turtle format</p> <p>Turtle spec</p>"},{"location":"concepts_2/","title":"RDF, a bit more advanced concepts","text":""},{"location":"concepts_2/#learning-outcomes","title":"Learning outcomes","text":"<p>After having completed this chapter, you will be able to:</p> <ul> <li>Understand RDF and SPARQL more advanced concepts</li> </ul>"},{"location":"concepts_2/#material","title":"Material","text":"<p> Download the presentation</p> <p>RDF spec</p>"},{"location":"course_schedule/","title":"Course schedule","text":"start end topic 09:30 10:00 SPARQL: introduction to basic concepts - M. Pagni 10:00 10:30 GraphDB intro - F. Burdet 10:30 11:30 A music example - F. Burdet 11:30 11:45 BREAK 11:45 12:30 A biological example - S. Moretti 12:30 13:30 LUNCH Afternoon 13:30 14:30 SPARQL: more advanced concepts - M. Pagni 14:30 15:00 SPARQL in the real world - S. Moretti 15:00 16:15 A biological example - S. Moretti 16:15 16:30 BREAK 16:30 17:00 What about Recon4IMD? The ReconXKG graph"},{"location":"demo/","title":"GraphDB demo","text":""},{"location":"demo/#learning-outcomes","title":"Learning outcomes","text":"<p>After this demo, you will be able to:</p> <ul> <li>Navigate through GraphDB and use its basic features</li> </ul>"},{"location":"demo/#material","title":"Material","text":"<p>We uploaded a Beatles database on the reconx server, based on this tutorial and data from Stardog (another semantic graph database).</p> <p>Let\u2019s look at the (few) in this database:</p> beatles_notsimplified.ttl<pre><code>PREFIX : &lt;http://contextualise.dev/ontology/&gt;\nPREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\nPREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;\n\n:The_Beatles      rdf:type  :Band .\n:The_Beatles      :name     \"The Beatles\" .\n:The_Beatles      :member   :John_Lennon .\n:The_Beatles      :member   :Paul_McCartney .\n:The_Beatles      :member   :Ringo_Starr .\n:The_Beatles      :member   :George_Harrison .\n:John_Lennon      rdf:type  :SoloArtist .\n:Paul_McCartney   rdf:type  :SoloArtist .\n:Ringo_Starr      rdf:type  :SoloArtist .\n:George_Harrison  rdf:type  :SoloArtist .\n:Please_Please_Me rdf:type  :Album .\n:Please_Please_Me :name     \"Please Please Me\" .\n:Please_Please_Me :date     \"1963-03-22\"^^xsd:date .\n:Please_Please_Me :artist   :The_Beatles .\n:Please_Please_Me :track    :Love_Me_Do .\n:Love_Me_Do       rdf:type  :Song .\n:Love_Me_Do       :name     \"Love Me Do\" .\n:Love_Me_Do       :length   125 .\n:Love_Me_Do       :writer   :John_Lennon .\n:Love_Me_Do       :writer   :Paul_McCartney .\n</code></pre> <p>Let\u2019s look at its structure when connecting the entities:</p> <p></p> <p>What is the longest path of relations going in the same direction?</p> <p>Now let\u2019s browse through it on the graphdb interface!</p> <p>Goal: browse through the longest path forth and back!</p> <p>See that the data can be visualized as tables or as visual graph.</p>"},{"location":"gba1/","title":"GBA1 \u2018Lysosomal acid glucosylceramidase\u2019","text":""},{"location":"gba1/#learning-outcomes","title":"Learning outcomes","text":"<p>After having completed this chapter, you will be able to:</p> <ul> <li>Understand the structure of a simple \u2018<code>biological</code>\u2019 database encoded in Turtle</li> <li>Write simple SELECT SPARQL queries</li> </ul>"},{"location":"gba1/#material","title":"Material","text":"<p>The exercises below follow the same structure as the music example, with a focus on the GBA1 gene involved in the Gaucher disease.</p>"},{"location":"gba1/#gba1-graph-exploration","title":"GBA1 graph exploration","text":"<p>Take some time to explore the <code>GBA1</code> protein graph.</p> <p>It has a lot of classes connecting the different knowledges curated and aggregated by the UniProt team.</p> <p></p> <p></p>"},{"location":"gba1/#gba1-graph-sparql-queries","title":"GBA1 graph SPARQL queries","text":"<p>We will do some exercises on the GBA1 graph, with a focus on the reactions catalyzed by the enzyme GBA1.</p>"},{"location":"gba1/#describe","title":"DESCRIBE","text":"<p>You have seen during the graph exploration that some properties can be cryptic, their name is not always meaningful.</p> <p>The <code>DESCRIBE</code> command is for you! As its name suggests, <code>DESCRIBE</code> provides a useful fragment of RDF, such as all the known details for each URI found.</p> Describe_up:catalyzedReaction.sparql<pre><code># Describe the up:catalyzedReaction property\n\nPREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nDESCRIBE up:catalyzedReaction\n</code></pre> <p>Exercise:</p> <ul> <li>Where is the <code>up:catalyzedReaction</code> property found in the graph?</li> <li>In which predicates is it involved?</li> </ul> Answer <pre><code>     subject                 predicate             object\n1    up:catalyzedReaction    rdf:type              rdf:Property\n2    up:catalyzedReaction    rdfs:subPropertyOf    up:catalyzedReaction\n3    up:catalyzedReaction    rdfs:subPropertyOf    up:catalyzedReaction\n</code></pre> <p></p>"},{"location":"gba1/#select","title":"SELECT","text":"<p>What is the GBA1 protein name?</p> <p>The predicate qualifying the protein name is <code>up:fullName</code>.</p> <p>Exercise: Use this predicate to find the GBA1 protein (full) name.</p> <p>A <code>SELECT</code> manual can be found here.</p> Answer <p>Protein_name.sparql<pre><code># Retrieve the protein name associated with the P04062 UniProt entry\n\nPREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nSELECT ?protein_name WHERE {\n    ?s up:fullName ?protein_name .\n}\n</code></pre> <pre><code>####################################################################\n\n      protein_name\n1    \"Lysosomal acid glucosylceramidase\"\n</code></pre></p> <p>There are in fact several names, with time this protein has accumulated a lot of aliases.</p> <p></p>"},{"location":"gba1/#select-and-order","title":"SELECT and ORDER","text":"<p>Which reactions are catalyzed by this enzyme?</p> <p>Exercise: Using the <code>up:catalyzedReaction</code> predicate, get the reactions catalyzed by GBA1.</p> Answer <p>This_enz_catalyses.sparql<pre><code># Which reactions are catalyzed by this enzyme?\n\nPREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nSELECT ?reactions WHERE {\n    ?s up:catalyzedReaction ?reactions .\n}\n</code></pre> <pre><code>##########################################\n\n      reactions\n1     http://rdf.rhea-db.org/13269\n2     http://rdf.rhea-db.org/14297\n3     http://rdf.rhea-db.org/11956\n4     http://rdf.rhea-db.org/58264\n5     http://rdf.rhea-db.org/58324\n6     http://rdf.rhea-db.org/58316\n7     http://rdf.rhea-db.org/70303\n8     http://rdf.rhea-db.org/70307\n9     http://rdf.rhea-db.org/70311\n10    http://rdf.rhea-db.org/70315\n11    http://rdf.rhea-db.org/70235\n12    http://rdf.rhea-db.org/70255\n13    http://rdf.rhea-db.org/70239\n14    http://rdf.rhea-db.org/70251\n</code></pre></p> <p>All GBA1 catalyzed reactions are reactions in Rhea.</p> <p>Exercise: Order this list by descending Rhea ids</p> Answer <p><pre><code># Which reactions are catalyzed by this enzyme?\n\nPREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nSELECT ?reactions WHERE {\n    ?s up:catalyzedReaction ?reactions .\n}\nORDER BY DESC(?reactions)\n</code></pre> <pre><code>##########################################\n\n      reactions\n1     http://rdf.rhea-db.org/70315\n2     http://rdf.rhea-db.org/70311\n3     http://rdf.rhea-db.org/70307\n4     http://rdf.rhea-db.org/70303\n5     http://rdf.rhea-db.org/70255\n6     http://rdf.rhea-db.org/70251\n7     http://rdf.rhea-db.org/70239\n8     http://rdf.rhea-db.org/70235\n9     http://rdf.rhea-db.org/58324\n10    http://rdf.rhea-db.org/58316\n11    http://rdf.rhea-db.org/58264\n12    http://rdf.rhea-db.org/14297\n13    http://rdf.rhea-db.org/13269\n14    http://rdf.rhea-db.org/11956\n</code></pre></p> <p></p>"},{"location":"gba1/#select-with-multiple-triples","title":"SELECT (with multiple triples)","text":"<p>What are the reactions associated with an EC number?</p> <p>The GBA1 graph contains also an enzyme class (<code>up:enzymeClass</code> predicate).</p> <p>Exercise: Get the GBA1 Rhea reactions associated with an EC number</p> Answer <p><pre><code># What are Rhea reactions associated with an EC number?\n\nPREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nSELECT ?rhea ?EC WHERE {\n    ?CatalyticActivity  up:catalyzedReaction   ?rhea .\n    ?CatalyticActivity  up:enzymeClass         ?EC .\n}\n</code></pre> <pre><code>##########################################\n\n     rhea                            EC\n1    http://rdf.rhea-db.org/13269    enzyme:3.2.1.45\n2    http://rdf.rhea-db.org/14297    enzyme:3.2.1.46\n</code></pre></p> <p>The two triples use the same subject named <code>?CatalyticActivity</code> in this example.</p> <p>The query can be simplified with the ; punctuation sign.</p> <p>Exercise: Simplify the previous query with ;</p> Answer <p><pre><code># What are Rhea reactions associated with an EC number?\n\nPREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nSELECT ?rhea ?EC WHERE {\n    ?CatalyticActivity  up:catalyzedReaction   ?rhea ;\n                        up:enzymeClass         ?EC .\n}\n</code></pre> <pre><code>##########################################\n\n     rhea                            EC\n1    http://rdf.rhea-db.org/13269    enzyme:3.2.1.45\n2    http://rdf.rhea-db.org/14297    enzyme:3.2.1.46\n</code></pre></p> <p></p>"},{"location":"gba1/#select-and-optional","title":"SELECT and OPTIONAL","text":"<p>What are the reactions associated with an EC number, and those which are not?</p> <p>We have seen previously that GBA1 catalyzes 14 reactions. All of them are linked to Rhea, but not all of them are linked to an EC number.</p> <p>Exercise: Get all the GBA1 Rhea reactions associated with an EC number or not</p> <p>A <code>OPTIONAL</code> manual can be found here.</p> Answer <p><pre><code># What are reactions associated or not with an EC number?\n\nPREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nSELECT ?reaction ?EC  WHERE {\n        ?CatalyticActivity  up:catalyzedReaction  ?reaction .\n    OPTIONAL {\n        ?CatalyticActivity  up:enzymeClass        ?EC .\n    }\n}\n</code></pre> <pre><code>##########################################\n\n     reaction                        EC\n1    http://rdf.rhea-db.org/13269    enzyme:3.2.1.45\n2    http://rdf.rhea-db.org/14297    enzyme:3.2.1.46\n3    http://rdf.rhea-db.org/11956    \n4    http://rdf.rhea-db.org/58264    \n5    http://rdf.rhea-db.org/58324    \n6    http://rdf.rhea-db.org/58316    \n7    http://rdf.rhea-db.org/70303    \n8    http://rdf.rhea-db.org/70307    \n9    http://rdf.rhea-db.org/70311    \n10   http://rdf.rhea-db.org/70315    \n11   http://rdf.rhea-db.org/70235    \n12   http://rdf.rhea-db.org/70255    \n13   http://rdf.rhea-db.org/70239    \n14   http://rdf.rhea-db.org/70251    \n</code></pre></p> <p></p>"},{"location":"gba1/#select-and-filter","title":"SELECT and FILTER","text":"<p>The results of the previous query are URI. You can see that by clicking on the Raw response button in the GraphDB result section.</p> <p>To filter on them, and apply comparison operators you have seen in the music example, you have to turn them (cast them) in a category easier to work on.</p> <p>You can stringify a URI/IRI with the <code>STR</code> function (A <code>STR</code> manual can be found here).</p> <p>E.g. <code>STR(?reaction)</code></p> <p>Exercise: From the previous SPARQL query, filter them to get only reactions upper than \u201chttp://rdf.rhea-db.org/13269\u201d</p> Answer <p><pre><code># What are reactions associated or not with an EC number, only with reactions upper than \"http://rdf.rhea-db.org/13269\"?\n\nPREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nSELECT ?reaction ?EC  WHERE {\n        ?CatalyticActivity  up:catalyzedReaction  ?reaction .\n    OPTIONAL {\n        ?CatalyticActivity  up:enzymeClass        ?EC .\n    }\n    FILTER( STR(?reaction) &gt; \"http://rdf.rhea-db.org/13269\" )\n}\n</code></pre> <pre><code>##########################################\n\n     reaction                        EC\n1    http://rdf.rhea-db.org/14297    enzyme:3.2.1.46\n2    http://rdf.rhea-db.org/58264\n3    http://rdf.rhea-db.org/58324\n4    http://rdf.rhea-db.org/58316\n5    http://rdf.rhea-db.org/70303\n6    http://rdf.rhea-db.org/70307\n7    http://rdf.rhea-db.org/70311\n8    http://rdf.rhea-db.org/70315\n9    http://rdf.rhea-db.org/70235\n10   http://rdf.rhea-db.org/70255\n11   http://rdf.rhea-db.org/70239\n12   http://rdf.rhea-db.org/70251\n</code></pre></p> <p>The <code>FILTER</code> function is very powerful. It can be combined with the <code>REGEX()</code> function to do almost everything you can think of (REGEX manual).</p> <p></p>"},{"location":"gba1/#select-and-bind","title":"SELECT and BIND","text":"<p>The <code>STR()</code> cast can be assigned in a new variable.</p> <p>Exercise: Use the <code>BIND</code> function to do it</p> <p>A <code>BIND</code> manual can be found here.</p> Answer <pre><code># What are reactions associated or not with an EC number, only with reactions upper than \"http://rdf.rhea-db.org/13269\"?\n\nPREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nSELECT ?reaction ?EC  WHERE {\n        ?CatalyticActivity  up:catalyzedReaction  ?reaction .\n    OPTIONAL {\n        ?CatalyticActivity  up:enzymeClass        ?EC .\n    }\n    BIND ( STR(?reaction) AS ?reac_string )\n    FILTER( ?reac_string &gt; \"http://rdf.rhea-db.org/13269\" )\n}\n</code></pre> <p>EC numbers are easily identifiable. We don\u2019t really need the enzyme: prefix.</p> <p>The <code>REPLACE</code> function is here for that (REPLACE manual). It replaces all occurences of a pattern by another pattern.</p> <p>Exercise: Remove the enzyme: prefix, i.e. replace it by nothing, in a <code>BIND</code> function.</p> <p>Think to stringify <code>?EC</code> first.</p> Answer <p><pre><code># What are reactions associated or not with an EC number, only with reactions upper than \"http://rdf.rhea-db.org/13269\"?\n\nPREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nSELECT ?reaction ?ec  WHERE {\n        ?CatalyticActivity  up:catalyzedReaction  ?reaction .\n    OPTIONAL {\n        ?CatalyticActivity  up:enzymeClass        ?EC .\n    }\n    BIND ( STR(?reaction) AS ?reac_string )\n    BIND ( REPLACE( STR(?EC), \"enzyme:\", \"\" ) AS ?ec )\n    FILTER( ?reac_string &gt; \"http://rdf.rhea-db.org/13269\" )\n}\n</code></pre> <pre><code>##########################################\n\n     reaction                        EC\n1    http://rdf.rhea-db.org/14297    \"http://purl.uniprot.org/enzyme/3.2.1.46\"\n</code></pre></p> <p>The stringification transforms <code>?EC</code> in its prefixed literal form <code>\"http://purl.uniprot.org/enzyme/3.2.1.46\"</code>.</p> <p>The right <code>REPLACE</code> pattern to apply is</p> Answer <p><pre><code>BIND ( REPLACE( STR(?EC), \"http://purl.uniprot.org/enzyme/\", \"\" ) AS ?ec )\n# for regex lovers\nBIND ( REPLACE( STR(?EC), \"^.*enzyme/\", \"\" ) AS ?ec )\n</code></pre> <pre><code>##########################################\n\n     reaction                        EC\n1    http://rdf.rhea-db.org/14297    \"3.2.1.46\"\n</code></pre></p> <p></p>"},{"location":"gba1/#select-and-aggregation","title":"SELECT and aggregation","text":"<p>Go back to the SELECT and OPTIONAL query.</p> <p>Exercise:  We want now to <code>COUNT</code> how many reactions are found by this SPARQL query.</p> <p>A <code>COUNT</code> manual can be found here or here.</p> Answer <p><pre><code># How many reactions associated or not with an EC number?\n\nPREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nSELECT (COUNT(?reaction) AS ?count) WHERE {\n        ?CatalyticActivity  up:catalyzedReaction  ?reaction .\n    OPTIONAL {\n        ?CatalyticActivity  up:enzymeClass        ?EC .\n    }\n}\n</code></pre> <pre><code>##########################################\n\n     count\n1    \"14\"^^xsd:integer\n</code></pre></p> <p>You can notice that the returned result has the right type for a number i.e. <code>xsd:integer</code>.</p> <p></p>"},{"location":"gba1/#select-and-group-by","title":"SELECT and GROUP BY","text":"<p>Exercise:  We want now to <code>COUNT</code> per EC number, i.e to know how many time each EC number is found.</p> <p>A <code>GROUP BY</code> manual can be found here.</p> Answer <p><pre><code># How many reactions associated with each EC number?\n\nPREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nSELECT ?EC (COUNT(?reaction) AS ?count) WHERE {\n        ?CatalyticActivity  up:catalyzedReaction  ?reaction .\n    OPTIONAL {\n        ?CatalyticActivity  up:enzymeClass        ?EC .\n    }\n}\nGROUP BY ?EC\n</code></pre> <pre><code>##########################################\n\n     EC                 count\n1    enzyme:3.2.1.45    \"1\"^^xsd:integer\n2    enzyme:3.2.1.46    \"1\"^^xsd:integer\n3                       \"12\"^^xsd:integer\n</code></pre></p> <p></p>"},{"location":"gba1/#property-paths","title":"Property paths","text":"<p>Property paths are the way two items are connected. The simplest path is just a single property, which forms an ordinary triple:</p> <pre><code>?item  path  ?property\n?item  ---&gt;  ?property\n</code></pre> <p>If items are not directly connected, their paths are longer. You can add path elements with a forward slash (<code>/</code>).</p> <p><code>?item path1/path2/path3 ?property</code></p> <p>This is equivalent to either of the following:</p> <pre><code>?item   path1  ?temp1 .\n?temp1  path2  ?temp2 .\n?temp2  path3  ?property .\n</code></pre> <p>or</p> <pre><code>?item path1 [ path2 [ path3 ?property ] ] .\n</code></pre> <p>A property paths manual can be found here.</p> <p></p> <pre><code>?protein                        up:annotation         ?catalytic_activity_annotation .\n?catalytic_activity_annotation  up:catalyticActivity  ?activity .\n?activity                       up:catalyzedReaction  ?rhea .\n</code></pre> <p>Exercise: Using property paths, simplify the query above:</p> Answer <p><pre><code># Use property paths to simplify the previous query\n\nPREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nSELECT ?protein ?rhea WHERE {\n    ?protein up:annotation/up:catalyticActivity/up:catalyzedReaction ?rhea .\n}\n</code></pre> <pre><code>##########################################\n\n      protein                                   rhea\n1     http://purl.uniprot.org/uniprot/P04062    http://rdf.rhea-db.org/13269\n2     http://purl.uniprot.org/uniprot/P04062    http://rdf.rhea-db.org/14297\n3     http://purl.uniprot.org/uniprot/P04062    http://rdf.rhea-db.org/11956\n4     http://purl.uniprot.org/uniprot/P04062    http://rdf.rhea-db.org/58264\n5     http://purl.uniprot.org/uniprot/P04062    http://rdf.rhea-db.org/58324\n6     http://purl.uniprot.org/uniprot/P04062    http://rdf.rhea-db.org/58316\n7     http://purl.uniprot.org/uniprot/P04062    http://rdf.rhea-db.org/70303\n8     http://purl.uniprot.org/uniprot/P04062    http://rdf.rhea-db.org/70307\n9     http://purl.uniprot.org/uniprot/P04062    http://rdf.rhea-db.org/70311\n10    http://purl.uniprot.org/uniprot/P04062    http://rdf.rhea-db.org/70315\n11    http://purl.uniprot.org/uniprot/P04062    http://rdf.rhea-db.org/70235\n12    http://purl.uniprot.org/uniprot/P04062    http://rdf.rhea-db.org/70255\n13    http://purl.uniprot.org/uniprot/P04062    http://rdf.rhea-db.org/70239\n14    http://purl.uniprot.org/uniprot/P04062    http://rdf.rhea-db.org/70251\n</code></pre></p> <p>Note we follow the directions shown as arrows on the graph picture, from the light green <code>P04062</code>, to the dark yellow <code>SIPEEA5CAFFB8CFF4D9</code>, to the light blue <code>SIP7F4F633380447C8F</code>, then to the red <code>13269</code>.</p>"},{"location":"gba1/#inverse-path","title":"Inverse path","text":"<p>To go in the other direction, i.e. in the opposite direction the arrows go, we have to use inverse path.</p> <p>Adding the symbol ^ in front of a predicate (or a property path expression) makes it an inverse path expression. An inverse path expression simply flips the direction of the match: the subject of the triple pattern will match the object of the triple in the data, and the object of the triple pattern will match the subject.</p> <p>Exercise: Write a query to display EC numbers and associated Rhea (from red <code>13269</code> to red <code>3.2.1.45</code> in the graph picture above).</p> Answer <pre><code>PREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nSELECT * WHERE {\n    ?rhea ^up:catalyzedReaction/up:enzymeClass ?EC .\n}\n</code></pre>"},{"location":"gba1/#recursive-path","title":"Recursive path","text":"<p>An enzyme hierarchy RDF has also been added in the <code>GBA1</code> graph.</p> <p>The <code>skos:broaderTransitive</code> predicate allows to go up in the EC number hierarchy, one parent at the time.</p> <p>Exercise: From the property path example, display the parents of the EC numbers found in GBA1.</p> Answer <pre><code>PREFIX skos: &lt;http://www.w3.org/2004/02/skos/core#&gt;\nPREFIX up: &lt;http://purl.uniprot.org/core/&gt;\nSELECT DISTINCT ?EC2 WHERE {\n    ?protein up:annotation/up:catalyticActivity/up:enzymeClass ?EC .\n    ?EC skos:broaderTransitive+ ?EC2 .\n}\n</code></pre>"},{"location":"gba1_ttl/","title":"GBA1 \u2018Lysosomal acid glucosylceramidase\u2019 Turtle","text":""},{"location":"gba1_ttl/#learning-outcomes","title":"Learning outcomes","text":"<p>After having completed this chapter, you will be able to:</p> <ul> <li>Get a Turtle file from a UniProt entry</li> <li>Import a Turtle file in GraphDB</li> </ul>"},{"location":"gba1_ttl/#material","title":"Material","text":"<p>The exercises below follow the same structure as the music example, with a focus on the GBA1 gene involved in the Gaucher disease.</p> <p>Let\u2019s look at the GBA1 entry in UniProt:</p> <p></p> <p>Some variants of this protein caused the Gaucher disease.</p> <p></p>"},{"location":"gba1_ttl/#export-a-ttl-turtle-file-from-uniprot","title":"Export a ttl (Turtle) file from UniProt","text":"<p>A Turtle file can be exported directly from a UniProt entry page.</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"gba1_ttl/#import-a-ttl-file-in-graphdb","title":"Import a ttl file in GraphDB","text":""},{"location":"gba1_ttl/#create-a-new-repository","title":"Create a new repository","text":"<p>Go to the GraphDB main screen</p> <p></p> <p>Create a new repository to work in</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"gba1_ttl/#import-a-ttl-file","title":"Import a ttl file","text":"<p>A Turtle file can be easily imported in GraphDB</p> <p></p> <p>Select Upload RDF files, and upload your Turtle file(s)</p> <p></p> <p></p> <p></p> <p>The GraphDB main page shows statistics about the data in your repository</p> <p></p> <p>Next Queries on the GBA1 graph</p>"},{"location":"interesting_endpoints/","title":"Interesting SPARQL endpoint resources","text":"<p>Here is a list of SPARQL endpoints interesting directly or indirectly for Recon4IMD</p> <ul> <li>UniProt \u201cworld\u2019s leading high-quality, comprehensive and freely accessible resource of protein sequence and functional information\u201d</li> <li>Rhea \u201cexpert-curated knowledgebase of chemical and transport reactions of biological interest\u201d</li> <li>MetaNetX \u201cunified namespace for metabolites and biochemical reactions in the context of metabolic models\u201d</li> <li>Lipid Maps \u201cLIPID Metabolites And Pathways Strategy - access to a large number of globally used lipidomics resources\u201d</li> <li>SwissLipids \u201cBeta A knowledge resource for lipids and their biology\u201d</li> <li>Bgee \u201cretrieval and comparison of gene expression patterns on curated, healthy wild-type, expression data\u201d</li> <li>Wikidata \u201cfree and open knowledge base that can be read by both humans and machines, central storage for the structured data of Wikipedia\u201d</li> </ul> <p>Registries of SPARQL endpoints</p> <ul> <li>Wikidata \u201clists SPARQL endpoints, all categories\u201d</li> <li>YummyData \u201clists and monitors SPARQL endpoints that provide data of interest to the biomedical community\u201d</li> </ul>"},{"location":"music/","title":"Basic SPARQL tutorial on a music example","text":""},{"location":"music/#learning-outcomes","title":"Learning outcomes","text":"<p>After having completed this chapter, you will be able to:</p> <ul> <li>Understand the structure of a simple database encoded in turtle</li> <li>Write simple SELECT SPARQL queries</li> </ul> <p>First, a toy example showing examples of queries and solutions  Download the presentation</p> <p>This is a do-it-yourself tutorial! We are here for questions and can discuss some of the exercices together!</p>"},{"location":"music/#material","title":"Material","text":"<p>The exercises below are based on this tutorial and data from Stardog.</p> <p>We will still use the \u201cmusic\u201d database that we explored in graphdb, below is a short extract with the Beatles as a reminder :</p> beatles_simplified.ttl<pre><code>PREFIX : &lt;http://contextualise.dev/ontology/&gt;\nPREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\nPREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;\n\n:The_Beatles      a :Band ;\n                  :name \"The Beatles\" ;\n                  :member :John_Lennon , :Paul_McCartney , :George_Harrison, :Ringo_Starr .\n:John_Lennon      a :SoloArtist .\n:Paul_McCartney   a :SoloArtist .\n:Ringo_Starr      a :SoloArtist .\n:George_Harrison  a :SoloArtist .\n:Please_Please_Me a :Album ;\n                  :name \"Please Please Me\" ;\n                  :date \"1963-03-22\"^^xsd:date ;\n                  :artist :The_Beatles ;\n                  :track :Love_Me_Do .\n:Love_Me_Do       a :Song ;\n                  :name \"Love Me Do\" ;\n                  :length 125 ;\n                  :writer :John_Lennon , :Paul_McCartney .\n</code></pre> <p>What is different from the previous example?</p> <p>Let\u2019s use this music database to write (not too complicated) SPARQL queries:</p> <p>You can copy the queries from here and paste them in the SPARQL interface:</p> <p></p> <p>Note that you can auto-complete using alt-enter!</p>"},{"location":"music/#describe","title":"DESCRIBE","text":"<p>If you want to know everything in our db about Adele, you can type</p> <pre><code>DESCRIBE &lt;http://stardog.com/tutorial/Adele&gt;\n</code></pre> <p>which can also be written as</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\nDESCRIBE :Adele\n</code></pre> <p>which will be used in the next examples in order to simplify the writing.</p>"},{"location":"music/#select","title":"SELECT","text":"<p>Select the albums from our database:</p> select_album.sparql<pre><code>PREFIX : &lt;http://stardog.com/tutorial/&gt;\nPREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\n\nSELECT ?album\nWHERE {\n   ?album rdf:type :Album .\n}\n</code></pre> <p>Exercise: Now adapt the query to select all the solo artists</p> Answer <pre><code>PREFIX : &lt;http://stardog.com/tutorial/&gt;\nPREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\n\nSELECT ?artist\nWHERE {\n    ?artist rdf:type :SoloArtist .\n}\n</code></pre>"},{"location":"music/#basic-graph-patterns","title":"Basic Graph Patterns","text":"<p>When one or more triple patterns are used together, they form what is known as a Basic Graph Pattern (BGP). Let\u2019s add one more triple pattern to our previous query to retrieve the artist for each album:</p> <pre><code>PREFIX : &lt;http://stardog.com/tutorial/&gt;\nPREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\n\nSELECT *\nWHERE {\n    ?album rdf:type :Album .\n    ?album :artist ?artist .\n}\n</code></pre> <p>What does the * mean here?</p> <p>Exercise: Add the solo artists and album \u201cnice\u201d names to this query. Hide the IDs from the results. Reorder the columns by artist - album</p> Answer <pre><code>PREFIX : &lt;http://stardog.com/tutorial/&gt;\nPREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\n\nSELECT ?artist_name ?album_name\nWHERE {\n  ?album rdf:type :Album .\n  ?album :name ?album_name .\n  ?album :artist ?artist .\n  ?artist :name ?artist_name .\n}\n</code></pre> <p>Now let\u2019s add a third triple pattern to require that the returned artists should be of the SoloArtist type:</p> <pre><code>PREFIX : &lt;http://stardog.com/tutorial/&gt;\nPREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\n\nSELECT *\n{\n   ?album a :Album .\n   ?album :artist ?artist .\n   ?artist a :SoloArtist .\n}\n</code></pre> <p>The third pattern matches 276 triples in our graph by itself, but because some solo artists have put out more than one album, 604 results are returned.</p> <p>Note: be aware that :artist can be either a band or a solo artist:</p> <p></p> <p>The predicate linking albums to solo artists or bands is the same: artist ! Anthology_2 contains songs by the group Beatles and solo artist Paul McCartney.</p>"},{"location":"music/#ordering-results","title":"Ordering Results","text":"<p>Now we\u2019ll run the following query, which includes album dates:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date .\n}\n</code></pre> <p>If we want the results to be ordered based on a sorting condition, we can add an ORDER BY:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date .\n}\nORDER BY ?date\n</code></pre> <p>Now albums will be returned ordered by their release dates.</p> <p>It is possible to have multiple sorting conditions by specifying multiple variables (or even function calls) in ORDER BY. We can also sort the results in descending order by encapsulating the sort condition with the DESC keyword, like this: DESC(?date).</p> <p>Limiting Results When a query returns too many results, we can limit the results with the LIMIT keyword:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date\n}\nORDER BY DESC(?date)\nLIMIT 2\n</code></pre> <p>In this query, we changed the dates to be sorted in reverse chronological order and limited the query to return only two results</p>"},{"location":"music/#filtering-results","title":"Filtering Results","text":"<p>We can filter the results returned by a query using a FILTER expression. SPARQL supports many built-in functions for writing such expressions:</p> <p>comparison operators: (=, !=, &lt;, &lt;=, &gt;, &gt;=) logical operators (&amp;&amp;, ||, !) mathematical operators (+, -, /, *)</p> <p>Plus many others.</p> <p>If we want to find the albums released in 1970 or later, we can do this with the following filter expression:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date\n   FILTER (?date &gt;= \"1970-01-01\"^^xsd:date)\n}\nORDER BY ?date\n</code></pre> <p>All otherwise matching results not satisfying the filter condition will be excluded from the results</p> <p>We can use any SPARQL function in the FILTER expressions. For example, the year function applied to a date value will return the year component as an integer value. So the following query will return the exact same results as the previous query, but the filter is written in a slightly different way:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date\n      FILTER (year(?date) &gt;= 1970)\n}\nORDER BY ?date\n</code></pre>"},{"location":"music/#binding-values","title":"Binding Values","text":"<p>We can assign the output of a function to a variable using the BIND keyword. This might be useful if we want to reuse the function result in different parts of the query or if we want to increase readability when we have a lot of nested function calls.</p> <p>We can rewrite the previous query by binding the output of the year(?date) expression to a new variable ?year first and using the variable in the filter expression:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date\n   BIND (year(?date) AS ?year)\n   FILTER (?year &gt;= 1970)\n}\nORDER BY ?date\n</code></pre> <p>Because we\u2019re selecting all variables with *, the new variable we\u2019ve bound will add another column to the output</p>"},{"location":"music/#removing-duplicates","title":"Removing Duplicates","text":"<p>Our music dataset is not complete by any means, and we have about a thousand albums. Suppose we want to find out the years in which these albums were released. One attempt would be to take the previous query, remove the filter, and only select the ?year variable.</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?year\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date\n   BIND (year(?date) AS ?year)\n}\nORDER BY ?date\n</code></pre> <p>But we will quickly discover that this query will still return many results, and the year values will be repeated:</p> <p>We can see that changing just the selected variables has no effect on the number of results returned by a query. We will still get one result for each matching pattern, so the number of rows in the result table won\u2019t change; only the number of columns will change.</p> <p>In order to get rid of duplicates, we need to use the DISTINCT keyword right after SELECT:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT DISTINCT ?year\n{\n   ?album a :Album ;\n          :artist ?artist ;\n          :date ?date\n   BIND (year(?date) AS ?year)\n}\nORDER BY ?year\n</code></pre> <p>The results won\u2019t have duplicates anymore</p>"},{"location":"music/#aggregation","title":"Aggregation","text":"<p>Aggregation is applying a function to a list of values rather than to a single value. Unlike regular functions, aggregate functions can only be used in SELECT expressions. Built-in aggregates provided in SPARQL are COUNT, SUM, MIN, MAX, AVG, GROUP_CONCAT, and SAMPLE.</p> <p>We can find the earliest and the latest release dates of albums in our dataset by using the MIN and MAX aggregates:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT (min(?date) as ?minDate) (max(?date) as ?maxDate)\n{\n    ?album a :Album ;\n           :date ?date\n}\n</code></pre> <p>We will get a single result with two columns</p> <p>The WHERE clause in this query would return a table with two columns and many rows if we didn\u2019t use the aggregate functions. The MIN (respectively, MAX) function looks at the values in the specified column of the results table and returns the single smallest (respectively, largest) value found.</p> <p>We can use the COUNT function to return the number of rows in the result table. The query to find the number of albums in our dataset is this:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT (count(?album) as ?count)\n{\n    ?album a :Album\n}\n</code></pre> <p>You can also count the relationships and how many times each type of relationship appears.</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?predicate (COUNT(?predicate) as ?predicateCount)\n{\n    ?subject ?predicate ?object .\n}\nGROUP BY ?predicate\nORDER BY DESC(?predicateCount)\n</code></pre>"},{"location":"music/#grouping","title":"Grouping","text":"<p>The previous aggregation examples worked over a single result table and returned a single row as the final result. We can also group the results based on the values of one or more variables and apply the aggregation functions to each group separately.</p> <p>Suppose we want to find the number of albums released each year. We can group the albums based on their release year and use the COUNT aggregate for each group:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?year (count(distinct ?album) AS ?count)\n{\n    ?album a :Album ;\n            :date ?date ;\n    BIND (year(?date) AS ?year)\n}\nGROUP BY ?year\nORDER BY DESC(?count)\n</code></pre> <p>We will get one result for each distinct year value.</p> <p>You might notice that we used the DISTINCT keyword inside the count aggregate. This is because some of the albums in our date have duplicate release dates. For example, the album \u201cA Hard Day\u2019s Night\u201d has both 1964-06-26 and 1964-07-10 as release dates. This is due to the imperfection of our dataset, and using the DISTINCT keyword ensures we count the album only once for that year.</p> <p>This is not a perfect solution since it means we\u2019ll double count albums if their multiple release dates are in different years. It\u2019s better to clean up the data. Fortunately, we can use the aggregates to find which albums have multiple release dates:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?album (group_concat(?date) AS ?dates)\n{\n    ?album a :Album ;\n            :date ?date\n}\nGROUP BY ?album\nHAVING (count(?date) &gt; 1)\n</code></pre> <p>The HAVING keyword we used at the end acts like an overall filter on the query results. Since the aggregates can only be used in SELECT expressions, we cannot use a regular FILTER (without introducing a subquery), so the HAVING keyword provides an easy way to define such filters.</p>"},{"location":"music/#subqueries","title":"Subqueries","text":"<p>If we want to find the average number of albums released in a year, we need to use an aggregation function over the results of the previous query. This can be achieved by subqueries where we simply put a SELECT query inside another one:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT (avg(?count) AS ?avgCount)\n{\n      SELECT ?year (count(?album) AS ?count)\n      {\n            ?album a :Album ;\n                  :date ?date ;\n            BIND (year(?date) AS ?year)\n      }\n      GROUP BY ?year\n}\n</code></pre> <p>The result of this query will be a single value.</p> <p>Of course, subqueries don\u2019t have to use aggregation; it would be fine to use any kind of SELECT query as a subquery. If the outer WHERE clause contains additional patterns, then the subquery should be surrounded with {}.</p>"},{"location":"music/#union","title":"Union","text":"<p>In our data, we have artists separated into two types: bands and solo artists. If we want to retrieve all artists along with their names, then we can use the UNION operator to combine the matches from two different patterns:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?name\n{\n    { ?artist a :SoloArtist }\n    UNION\n    { ?artist a :Band }\n    ?artist :name ?name\n}\n</code></pre> <p>The results will contain artists matching either pattern.</p> <p>If the same artists matched both patterns, we would get a duplicate result and need DISTINCT to get unique results.</p>"},{"location":"music/#optional-matches","title":"Optional Matches","text":"<p>The following query returns the songs and their lengths:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n    ?song a :Song .\n    ?song :length ?length .\n}\nLIMIT 5000 # included to override default limit\n</code></pre> <p>When we look at the results, we see this query returns 3,640 results.</p> <p>Whereas the query without the second pattern returns 3,749 songs:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n    ?song a :Song .\n}\nLIMIT 5000 # included to override default limit\n</code></pre> <p>This means there are 109 songs in our dataset that do not have any length information.</p> <p>We can use OPTIONAL blocks to match patterns that may exist for some nodes but not for others:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?song ?length\n{\n    ?song a :Song .\n    OPTIONAL {\n        ?song :length ?length .\n    }\n}\nLIMIT 5000 # included to override default limit\n</code></pre> <p>This query will return 3,749 results, where 109 rows will not have a value for the length.</p> <p>If we only want to see those rows where length is missing, we can add a filter to our query:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?song ?length\n{\n    ?song a :Song .\n    OPTIONAL {\n        ?song :length ?length .\n    }\n    FILTER(!bound(?length))\n}\n</code></pre> <p>And we get the 109 results we were expecting.</p>"},{"location":"music/#negation","title":"Negation","text":"<p>The last example shows a somewhat indirect way to find patterns that do not exist in the dataset by using a combination of OPTIONAL and FILTER expressions. But SPARQL provides a special kind of filter for this purpose: NOT EXISTS. The following query will return the same 109 results as the previous query:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?song\n{\n    ?song a :Song .\n    FILTER NOT EXISTS {\n        ?song :length ?length .\n    }\n}\n</code></pre> <p>Any SPARQL construct can be used inside a NOT EXISTS block.</p>"},{"location":"music/#property-paths","title":"Property Paths","text":"<p>The triple patterns match triples in the dataset, so they can only be used to find nodes that are directly connected. We can use property paths to match nodes that are connected via arbitrary-length paths. More generally, a property path is a regular expression describing the possible route between two nodes in a graph. Property paths can also be used to express some graph patterns more concisely.</p> <p>To explore what we can do with property paths, we will start with this query that uses two ordinary triple patterns to find pairs of people who wrote songs together:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT DISTINCT ?artist ?cowriter\n{\n    ?song :writer ?artist .\n    ?song :writer ?cowriter\n    FILTER (?artist != ?cowriter)\n}\n</code></pre> <p>We need DISTINCT in this query because the same pair might have cowritten multiple songs together. We need the FILTER because otherwise the query would match the songs with a single writer and bind the two variables ?artist and ?cowriter to the same person. Using a different variable does not ensure that the triple patterns match different triples in the data. This query returns each pair twice; we leave it as an exercise to the reader to come up with a different filter expression to return every pair only once.</p> Answer <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nselect distinct ?artist ?cowriter\n{\n    ?song :writer ?artist .\n    ?song :writer ?cowriter .\n    FILTER (?artist != ?cowriter &amp;&amp; STR(?artist) &lt; STR(?cowriter))\n}\n</code></pre>"},{"location":"music/#inverse-path","title":"INVERSE PATH","text":"<p>Adding the symbol ^ in front of a predicate (or a property path expression) makes it an inverse path expression. An inverse path expression simply flips the direction of the match: the subject of the triple pattern will match the object of the triple in the data, and the object of the triple pattern will match the subject. So an equivalent way to write the previous query is as follows:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT DISTINCT ?artist ?cowriter\n{\n    ?artist ^:writer ?song .\n    ?song :writer ?cowriter\n    FILTER (?artist != ?cowriter)\n}\n</code></pre> <p>By itself, an inverse property path expression is not very useful, but in combination with other property path expressions, it can be (as we will see next).</p>"},{"location":"music/#sequence-path","title":"SEQUENCE PATH","text":"<p>When the object of one triple pattern is the same as the subject of another triple pattern, and we are not interested in the binding of the variable, we can combine the two patterns using a sequence path. A sequence path means the subject is connected to the object via the path of property expressions specified in the sequence. The next query returns the same results as the previous query:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT DISTINCT ?artist ?cowriter\n{\n    ?artist ^:writer/:writer ?cowriter\n    FILTER (?artist != ?cowriter)\n}\n</code></pre> <p>There can be more than two expressions in a path if necessary. We can also use constants for the subject or the object, or both. The next query returns cowriters of Paul McCartney:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT DISTINCT ?cowriter\n{\n    :Paul_McCartney ^:writer/:writer ?cowriter\n    FILTER (?cowriter != :Paul_McCartney)\n}\norder by ?cowriter\n</code></pre>"},{"location":"music/#recursive-paths","title":"RECURSIVE PATHS","text":"<p>Suppose we want to find not only the cowriters of Paul McCartney, but also the cowriters of his cowriters, and continue finding cowriters recursively. We can use the recursive path operator + to follow a property path one or more times.</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT DISTINCT ?cowriter\n{\n    :Paul_McCartney (^:writer/:writer)+ ?cowriter\n    FILTER (?cowriter != :Paul_McCartney)\n}\norder by ?cowriter\n</code></pre> <p>The other recursive operator, * , is used to follow a path zero or more times. Following a path zero times means we don\u2019t traverse any edges, and simply return the same node as the starting node. This makes most sense when used in a sequence path as in rdf:type/rdfs:subClassOf*. This property path returns the type(s) of a node and all its superclasses.</p>"},{"location":"music/#optional-paths","title":"OPTIONAL PATHS","text":"<p>In our dataset, we have both the solo albums released by Paul McCartney and the albums released by The Beatles. The next query would return both kinds of album:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?album\n{\n  ?album :artist/:member? :Paul_McCartney\n}\n</code></pre> <p>The ? suffix means we should follow a path zero or one times. The property path expression :artist/:member? would start with an album and first find all the nodes connected via the :artist predicate and return those nodes (since we would end up on those nodes when we follow the :member edge zero times). Then, if any of those nodes have a :member edge, it will follow those edges and return the new nodes we reach as well.</p> <p>If you are not sure to understand, try to first run the query with only :artist. 17 solo albums by McCartney. Then add again :member, but remove the ? . 27 albums by the Beatles. Then re-run the original query: indeed 44 albums!</p>"},{"location":"music/#alternative-paths","title":"ALTERNATIVE PATHS","text":"<p>Suppose we want to find all the songs related to Paul McCartney: songs released in either his solo albums or The Beatles\u2019 albums, along with the songs he wrote that were recorded by other artists. We need to find three alternate paths from songs to Paul McCartney. The previous property path expression already (partially) encodes two of these paths, and the third alternate path can be introduced using the | path operator:</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT ?song\n{\n  ?song (^:track/:artist/:member?)|:writer :Paul_McCartney\n}\n</code></pre> <p>Remember that we need the :member? to get the paths to the solo songs by McCartney (:artist), and the paths that go on to the group, linked by :member.</p> <p>Why do we need the \u201c^\u201d for track? In case, go back to the simple scheme of the graph.</p> <p>To understand the \u201cor\u201d (|) part of the results better, one could split this request in 2 and have one part for track-artist-member UNION one part for the writer part, and bind these variables, in order to understand where the actual result comes from</p> Answer <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nSELECT *\n{\n    {\n    ?song (^:track/:artist/:member?):Paul_McCartney\n    BIND( \"^:track/:artist/:member?\" AS ?path )\n    } UNION {\n    ?song :writer :Paul_McCartney\n    BIND( \":writer\" AS ?path )\n    }\n}\n</code></pre> <p>But it is not possible to bind variables inside the paths.</p>"},{"location":"music/#construct","title":"CONSTRUCT","text":"<p>While the SELECT query form returns variable bindings, the CONSTRUCT query form returns an RDF graph.  The graph is built based on a template which is used to generate RDF triples based on the results of matching the graph pattern of the query.</p> <p>Say we want to select a sub graph where David Bowie is an artist and a producer, we could write</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\n\nCONSTRUCT WHERE\n{\n    ?s :producer :David_Bowie .\n    ?s :artist :David_Bowie ;\n        :track   ?track\n}\n</code></pre> <p>Try the Visual button on graphdb: you can visualize the constructed graph! (there is a limit to the number of links shown, changing this parameter will change the visual a lot)</p> <p>Interestingly enough, Bowie is often both producer and singer. Are there other examples of artists in that case? Could we possibly create a new predicate \u201cproducer and artist\u201d to make the results clearer?</p> <pre><code>prefix : &lt;http://stardog.com/tutorial/&gt;\nPREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\n\nCONSTRUCT { \n    :producer_and_artist a rdf:Property .\n    ?artist :producer_and_artist ?album .\n    } \nWHERE\n{\n    { ?artist :artist   ?album .\n      ?artist :producer ?album .\n    }\n}\n</code></pre> <p>You don\u2019t have write access on this repository, but you will see later that it is possible to update the graph to store this newly defined predicate, using the same WHERE clause!</p>"},{"location":"other_interfaces/","title":"Other SPARQL interfaces","text":"<p>Here is a list of SPARQL endpoints - integrated in the ReconXKG RDF - that can be useful to query individually.</p> <p>Note that they may rely on different RDF engines (i.e. GraphDB is not used everywhere).</p> <p>The Virtuoso engine is often used because it can manage larger amount of data, and is also freely available.</p>"},{"location":"other_interfaces/#uniprot","title":"UniProt","text":"<p>The UniProt SPARQL endpoint is available at https://sparql.uniprot.org/</p> <p></p>"},{"location":"other_interfaces/#rhea","title":"Rhea","text":"<p>The Rhea SPARQL endpoint is available at https://sparql.rhea-db.org/</p> <p></p>"},{"location":"other_interfaces/#metanetx","title":"MetaNetX","text":"<p>The MetaNetX SPARQL endpoint is available at https://rdf.metanetx.org/</p> <p></p>"},{"location":"other_interfaces/#remote-queries-with-service","title":"Remote queries with SERVICE","text":"<p>One of the strength of SPARQL queries is they can be remotely executed, opening the federated query way of querying.</p> <p>Exercise: Take an example query found in Rhea, and execute it from the reconx.vital-it.ch SPARQL interface.</p> <p>E.g.: <pre><code>PREFIX rh: &lt;http://rdf.rhea-db.org/&gt;\nPREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\nPREFIX pubmed: &lt;http://rdf.ncbi.nlm.nih.gov/pubmed/&gt;\n# Query 2\n# Select all Rhea reactions annotated with a given Pubmed identifier (PMID = 29867142)\n#\nSELECT ?pubmed ?rhea ?accession ?isTransport ?equation\nWHERE {\n    ?rhea rdfs:subClassOf rh:Reaction .\n    ?rhea rh:accession ?accession .\n    ?rhea rh:citation ?pubmed .\n    VALUES (?pubmed) { (pubmed:29867142) }\n    ?rhea rh:isTransport ?isTransport .\n    ?rhea rh:equation ?equation .\n} ORDER BY ?rhea\n</code></pre></p> <p>NB: The Rhea SPARQL endpoint URL is <code>https://sparql.rhea-db.org/</code>.</p> Answer <pre><code>PREFIX rh: &lt;http://rdf.rhea-db.org/&gt;\nPREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\nPREFIX pubmed: &lt;http://rdf.ncbi.nlm.nih.gov/pubmed/&gt;\n# Query 2\n# Select all Rhea reactions annotated with a given Pubmed identifier (PMID = 29867142)\n#\nSELECT ?pubmed ?rhea ?accession ?isTransport ?equation\nWHERE {\n    SERVICE &lt;https://sparql.rhea-db.org/&gt; {                  # &lt;--------------------\n        ?rhea rdfs:subClassOf rh:Reaction .\n        ?rhea rh:accession ?accession .\n        ?rhea rh:citation ?pubmed .\n        VALUES (?pubmed) { (pubmed:29867142) }\n        ?rhea rh:isTransport ?isTransport .\n        ?rhea rh:equation ?equation .\n    }                                                        # &lt;--------------------\n} ORDER BY ?rhea\n</code></pre>"},{"location":"precourse/","title":"Pre-course preparations","text":"<p>There is nothing to prepare!</p>"},{"location":"precourse/#software","title":"Software","text":"<p>We will be mainly working on a remote GraphDB instance, dedicated to Recon4IMD.</p> <p>Other SPARQL endpoints will also be used remotely.</p> <p>You can, if you want, install GraphDB on your own computer, but it is not needed for the course. The GraphDB semantic graph database is available for most computers here. Fill the form (Select <code>GraphDB Free</code>) to access the GraphDB download links.</p>"},{"location":"reconxkg/","title":"ReconXKG","text":""},{"location":"reconxkg/#material","title":"Material","text":"<p> Download the presentation</p>"}]}